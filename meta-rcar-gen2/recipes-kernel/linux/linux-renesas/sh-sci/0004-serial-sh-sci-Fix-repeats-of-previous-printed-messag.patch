From 0cb93b42b22eea71c4da84d8b0a20afbff603d26 Mon Sep 17 00:00:00 2001
From: Ryuichi Ando <ryuichi.ando.jz@ps.hitachi-solutions.com>
Date: Tue, 28 Jul 2015 20:23:57 +0900
Subject: [PATCH 04/13] serial: sh-sci: Fix repeats of previous printed
 messages in rebooting

A problem that previous printed messages are repeated occurs
in rebooting with DMA transfer enabled.
This is because SCIF driver doesn't care flush of UART ring buffer.

When DMA transfer completes, SCIF driver updates a tail index of UART ring
buffer, and checks a difference between a head and a tail.
If a head differs from a tail, SCIF driver transfers the difference.

Though, when the flush occurs, a head and a tail are both cleared
(become 0).
Therefore, if the flush occurs during DMA transfer,
updating a tail index causes a difference,
and then previous printed messages are transferred.

This patch fixes SCIF driver so that SCIF driver cares the flush during DMA
transfer.

1. Create a method, struct uart_ops.flush_buffer(sci_flush_buffer).
   When the flush occurs, this method is called from Serial core interface.

2. If sci_flush_buffer is called during DMA transfer,
   SCIF driver doesn't update tail of UART ring buffer.

Signed-off-by: Ryuichi Ando <ryuichi.ando.jz@ps.hitachi-solutions.com>
Signed-off-by: Hiroki Negishi <hiroki.negishi.zr@hitachi-solutions.com>
Signed-off-by: Kazuya Mizuguchi <kazuya.mizuguchi.ks@renesas.com>
---
 drivers/tty/serial/sh-sci.c | 21 +++++++++++++++++----
 drivers/tty/serial/sh-sci.h |  5 +++++
 2 files changed, 22 insertions(+), 4 deletions(-)

diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c
index abfbce3..21c797c 100644
--- a/drivers/tty/serial/sh-sci.c
+++ b/drivers/tty/serial/sh-sci.c
@@ -123,6 +123,7 @@ struct sci_port {
 	unsigned int			rx_timeout;
 	int				rx_flag;
 	int				rx_release_flag;
+	int				circ_flush_flag;
 #endif
 
 	struct notifier_block		freq_transition;
@@ -1276,10 +1277,11 @@ static void sci_dma_tx_complete(void *arg)
 
 	spin_lock_irqsave(&port->lock, flags);
 
-	xmit->tail += sg_dma_len(&s->sg_tx);
-	xmit->tail &= UART_XMIT_SIZE - 1;
-
-	port->icount.tx += sg_dma_len(&s->sg_tx);
+	if (s->circ_flush_flag == SCI_CIRC_FLSH_OFF) {
+		xmit->tail += sg_dma_len(&s->sg_tx);
+		xmit->tail &= UART_XMIT_SIZE - 1;
+		port->icount.tx += sg_dma_len(&s->sg_tx);
+	}
 
 	async_tx_ack(s->desc_tx);
 	s->desc_tx = NULL;
@@ -1555,6 +1557,7 @@ static void work_fn_tx(struct work_struct *work)
 	 * consistent xmit buffer state.
 	 */
 	spin_lock_irq(&port->lock);
+	s->circ_flush_flag = SCI_CIRC_FLSH_OFF;
 	sg->offset = xmit->tail & (UART_XMIT_SIZE - 1);
 	sg_dma_address(sg) = (sg_dma_address(sg) & ~(UART_XMIT_SIZE - 1)) +
 		sg->offset;
@@ -2017,6 +2020,15 @@ static void sci_baud_calc_hscif(unsigned int bps, unsigned long freq,
 	}
 }
 
+static void sci_flush_buffer(struct uart_port *port)
+{
+	struct sci_port *s = to_sci_port(port);
+
+#ifdef CONFIG_SERIAL_SH_SCI_DMA
+	s->circ_flush_flag = SCI_CIRC_FLSH_ON;
+#endif
+}
+
 static void sci_reset(struct uart_port *port)
 {
 	struct plat_sci_reg *reg;
@@ -2313,6 +2325,7 @@ static struct uart_ops sci_uart_ops = {
 	.break_ctl	= sci_break_ctl,
 	.startup	= sci_startup,
 	.shutdown	= sci_shutdown,
+	.flush_buffer	= sci_flush_buffer,
 	.set_termios	= sci_set_termios,
 	.pm		= sci_pm,
 	.type		= sci_type,
diff --git a/drivers/tty/serial/sh-sci.h b/drivers/tty/serial/sh-sci.h
index d5db81a..35be62a 100644
--- a/drivers/tty/serial/sh-sci.h
+++ b/drivers/tty/serial/sh-sci.h
@@ -36,3 +36,8 @@
 
 #define SCI_MAJOR		204
 #define SCI_MINOR_START		8
+
+#ifdef CONFIG_SERIAL_SH_SCI_DMA
+#define SCI_CIRC_FLSH_OFF	0
+#define SCI_CIRC_FLSH_ON	1
+#endif
-- 
1.9.1

